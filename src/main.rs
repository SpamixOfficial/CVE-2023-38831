use std::error::Error;
use std::fmt::Result;
use std::fs;
use std::io;
use std::path;
use std::process::exit;
use zip::write::FileOptions;
use zip::ZipWriter;

struct PartFile<'a> {
    role: &'a str,
    content: String,
}

fn main() {
    let mut bait = PartFile {
        role: "bait",
        content: String::new(),
    };
    let mut script = PartFile {
        role: "script",
        content: String::new(),
    };
    let mut out = String::new();

    println!("Please input your \"bait\" file name: ");
    io::stdin()
        .read_line(&mut bait.content)
        .expect("Error: couldn't read line");
    bait.content = bait.content.replace("\n", "").replace(" ", "");
    println!("Please input your \"script\" file name: ");
    io::stdin()
        .read_line(&mut script.content)
        .expect("Error: couldn't read line");
    script.content = script.content.replace("\n", "").replace(" ", "");

    println!("Please input your \"output\" file name: ");
    io::stdin()
        .read_line(&mut out)
        .expect("Error: couldn't read line");
    out = out.replace("\n", "").replace(" ", "");
     
    // path checking
    check_path(&bait);
    check_path(&script);

    // Move to new tmp folder
    let tmpfiles = copy_to_tmp((&bait, &script));

    // zip em up!
    create_zip(out.as_str(), tmpfiles.0.as_str(), (tmpfiles.1.as_path().display().to_string().as_str(), tmpfiles.2.as_path().display().to_string().as_str()))
    
}

fn check_path(filepath: &PartFile) {
    if path::Path::new(filepath.content.as_str()).exists() != true {
        println!(
            "Error: \"{}\" path \"{}\" doesn't exist!",
            filepath.role, filepath.content
        );
        exit(1);
    };
    if filepath.content.contains(".") != true {
        println!("Error! File may NOT be extensionless.");
        exit(1);
    }
    if filepath.role == "script" {
        if filepath.content.ends_with(".bat") != true && filepath.content.ends_with(".cmd") != true
        {
            println!("Error: Script must be a Windows Batch or CMD file!");
            exit(1);
        };
    };
}

fn copy_to_tmp(files: (&PartFile, &PartFile)) -> (String, path::PathBuf, path::PathBuf) {
    let tmp = path::Path::new("tmp");
    if tmp.exists() {
        let _ = fs::remove_dir_all("tmp");
    }
    let script = path::Path::new(files.1.content.as_str());
    let baitextension = &files.0.content[files.0.content.find(".").unwrap() + 1..];
    println!("{}", baitextension);
    let baitname = &files.0.content[..files.0.content.find(".").unwrap()];
    println!("{}", baitname);
    let tmpscriptpath = tmp.join("tmp1").join("tmp.cmd");
    let tmpfilepath = tmp.join("tmp1").join(String::from("tmp.") + baitextension);
    match fs::create_dir_all(tmp.join("tmp1")) {
        Ok(_) => {},
        Err(result) => {
            println!("{result}");
            exit(1);
        }
    };
    match fs::create_dir_all(tmp.join("tmp2")) {
        Ok(_) => {},
        Err(result) => {
            println!("{result}");
            exit(1);
        }
    };
    match fs::copy(script, &tmpscriptpath) {
        Ok(_) => {},
        Err(result) =>  {
            println!("Error: {result}");
            exit(1);
        }
    };
    match fs::copy(files.0.content.as_str(), &tmpfilepath) {
        Ok(_) => {},
        Err(result) =>  {
            println!("Error: {result}");
            exit(1);
        }
    };
    (String::from(baitname), tmpscriptpath, tmpfilepath)
}

fn create_zip(out_name: &str, baitname: &str, files: (&str, &str)) {
    let tmpscriptpath = files.0;
    let tmpfilepath = files.1;
    let zipname = if out_name.contains('.') { &out_name[..out_name.find('.').unwrap()] } else { out_name }; 
    let zip_path = path::Path::new("tmp").join("tmp2").join(String::from(zipname) + ".rar");
    println!("{}", zip_path.as_path().display().to_string().as_str());
}
